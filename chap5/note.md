# 函数语义学

### 静态成员函数

静态成员函数不能操作数据成员。

可以使用这种方法调用：`((MYCLS *)0)->staticFunc()`

### 虚函数的 vcall 引入

1. 调整 this 指针
2. 跳转到真实的虚函数中去

### 静态类型 与 动态类型

### 静态绑定 与 动态绑定

### 继承的坑（非虚函数）

### 单继承下的虚函数

### 多重继承的 虚析构

### 虚继承 + 虚函数

虚基类的所有成员都在最下面

### RTTI（运行时，类型识别）

通过 dynamic_cast 和 typeid 体现

### RTTI 实现原理

typeid 返回的是一个常亮对象的引用，这个常亮对象的类型一般是 type_info

```cpp
const std::type_info &tp = typeid(*pb);
```

RTTI 的测试能力，与基类中是否存在 虚函数表 有关系。

### 编译器对循环的优化

### 继承关系深度增加 / 多重继承，开销也增加

因为会在继承的时候，一层一层的调用构造函数

### 继承关系深度增加，虚函数导致的开销增加

因为会出现反复赋值的情况。

A --> B --> C

会先调用 A，对 vptr 赋值。B 对 vptr 赋值，C 对 vptr 赋值，
但是实际上，只有最有一层对 vptr 赋值才有用。
子类 一定会调用 父类 的构造函数的

### 成员函数指针 调用 成员函数（虚）

通过成员函数指针调用 虚函数，依然会走 虚函数表。

### vcall 有点不明白

vcall 对应的汇编代码中，有一个偏移值。
有了这个偏移值，我们就可以知道：调用的是哪一个虚函数。

### inline

inline 是：开发者对编译器的一种建议，至于编译器会不会去做，取决于编译器。
也有可能会出现 inline 失败的情况。
使用 inline 之后，编译器内部会有一个比较复杂的测试算法，
来评估这个 inline 函数的复杂度

#### （2）局部变量的引入

就是：减少 inline 函数中的 中间对象（变量）

#### （3）inline 失败

比方说，递归调用，就是不适合使用 inline。
当然，随着编译技术的发展，inline 成功的几率会越来越大。
如果想要知道 inline 是否成功，看汇编代码。
